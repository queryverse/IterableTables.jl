<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integration Guide · IterableTables.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IterableTables.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="userguide.html">User Guide</a></li><li class="current"><a class="toctext" href="integrationguide.html">Integration Guide</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Overview-1">Overview</a></li><li class="toplevel"><a class="toctext" href="#Consuming-iterable-tables-1">Consuming iterable tables</a></li><li><a class="toctext" href="#Reusing-an-existing-consumer-of-iterable-tables-1">Reusing an existing consumer of iterable tables</a></li><li><a class="toctext" href="#Coding-a-complete-conversion-1">Coding a complete conversion</a></li><li class="toplevel"><a class="toctext" href="#Creating-an-iterable-table-source-1">Creating an iterable table source</a></li><li><a class="toctext" href="#Directly-implementing-the-julia-base-iteration-trait-1">Directly implementing the julia base iteration trait</a></li><li><a class="toctext" href="#Creating-a-custom-iteration-type-1">Creating a custom iteration type</a></li></ul></li><li><a class="toctext" href="developerguide.html">Developer Guide</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="integrationguide.html">Integration Guide</a></li></ul><a class="edit-page" href="https://github.com/davidanthoff/IterableTables.jl/blob/master/docs/src/integrationguide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Integration Guide</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Integration-Guide-1" href="#Integration-Guide-1">Integration Guide</a></h1><p>This guide describes how package authors can integrate their own packages with the <code>IterableTables</code> ecosystem. Specifically, it explains how one can turn a type into an iterable table and how one can write code that consumes iterable tables.</p><h1><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h1><p>For now I recommend that all integrations with IterableTables should live in the IterableTables package. This is a temporary solution until the interface in IterableTables is more stable, at which point integrations will be moved into the packages that they integrate. So new integrations should at this point ideally be submitted as pull requests against the <a href="https://github.com/davidanthoff/IterableTables.jl">IterableTables repository</a>. Specifically, each integration should be put into a file in the folder <code>src/integrations</code>, and the filename should be the name of the package that is being integrated. The code in that file should live in a <code>@require</code> block (see one of the existing integrations for an example).</p><h1><a class="nav-anchor" id="Consuming-iterable-tables-1" href="#Consuming-iterable-tables-1">Consuming iterable tables</a></h1><p>One cannot dispatch on an iterable table because iterable tables don&#39;t have a common super type. Instead one has to add a method that takes any type as an argument to consume an iterable table. For conversions between types it is recommended that one adds a constructor that takes one argument without any type restriction that can convert an iterable table into the target type. For example, if one has added a new table type called <code>MyTable</code>, one would add a constructor with this method signature for this type: <code>function MyTable(iterable_table)</code>. For other situations, for example a plotting function, one also would add a method without any type restriction, for example <code>plot(iterable_table)</code>.</p><p>The first step inside any function that consumes iterable tables is to check whether the argument that was passed is actually an iterable table or not. This can easily be done with the <code>isiterabletable</code> function. For example, the constructor for a new table type might start like this:</p><pre><code class="language-julia">function MyTable(source)
    isiterabletable(source) || error(&quot;Argument is not an iterable table.&quot;)

    # Code that converts things follows
end</code></pre><p>Once it has been established that the argument is actually an iterable table there are multiple ways to proceed. The following two sections describe two options, which one is appropriate for a given situation depends on a variety of factors.</p><h2><a class="nav-anchor" id="Reusing-an-existing-consumer-of-iterable-tables-1" href="#Reusing-an-existing-consumer-of-iterable-tables-1">Reusing an existing consumer of iterable tables</a></h2><p>This option is by far the simplest way to add support for consuming an iterable table. Essentially the strategy is to reuse the conversion implementation of some other type. For example, one can simply convert the iterable table into a <code>DataFrame</code> right after one has checked that the argument of the function is actually an iterable table. Once the iterable table is converted to a <code>DataFrame</code>, one can use the standard API of <code>DataFrame</code>s to proceed. This strategy is especially simple for packages that already support interaction with <code>DataFrames</code> (or any of the other table types supported by IterableTables). The code for the <span>$MyTable$</span> constructor might look like this:</p><pre><code class="language-julia">function MyTable(source)
    isiterabletable(source) || error(&quot;Argument is not an iterable table.&quot;)

    df = DataFrame(source)
    return MyTable(df)
end</code></pre><p>This assumes that <code>MyTable</code> has another constructor that accepts a <code>DataFrame</code>.</p><p>Currently the most efficient table type for this kind of conversion is the <code>DataTable</code> type from the <a href="https://github.com/JuliaData/DataTables.jl">DataTables.jl</a> package. How efficient is this strategy in general? It really depends what is happening in the next step with say the <code>DataTable</code> one constructed. If the data will be copied into yet another data structure after it has been converted to a <code>DataTable</code>, one has added at least one unnecessary memory allocation in the conversion. For such a situation it is probably more efficient to manually code a complete version, as described in the next section. If, on the other hand, one for example requires a vector of values for each column of the table, this approach can be quite efficient: one can just access the vector in the <code>DataTable</code> and operate on that.</p><h2><a class="nav-anchor" id="Coding-a-complete-conversion-1" href="#Coding-a-complete-conversion-1">Coding a complete conversion</a></h2><p>Coding a custom conversion is more work than reusing an existing consumer of iterable tables, but it provides more flexibility.</p><p>In general, a custom conversion function also needs to start with a call to <code>isiterable</code> to check whether one actually has an iterable table. The second step in any custom conversion function is to all the <code>getiterator</code> function on the iterable table. This will return an instance of a type that implements the standard julia iterator interface, i.e. one can call <code>start</code>, <code>next</code> and <code>done</code> on the instance that is returned by <code>getiterator</code>. For some iterable tables <code>getiterator</code> will just return the argument that one has passed to it, but for other iterable tables it will return an instance of a different type.</p><p><code>getiterator</code> is generally not a type stable function. Given that this function is generally only called once per conversion this hopefully is not a huge performance issue. The functions that really need to be type-stable are <code>start</code>, <code>next</code> and <code>done</code> because they will be called for every row of the table that is to be converted. In general, these three functions will be type stable for the type of the return value of <code>getiterator</code>. But given that <code>getiterator</code> is not type stable, one needs to use a function barrier to make sure the three iteration functions are called from a type stable function.</p><p>The next step in a custom conversion function is typically to find out what columns the iterable table has. The helper functions <code>IterableTables.column_types</code> and <code>IterableTables.column_names</code> provide this functionality (note that these are not part of the official iterable tables interface, they are simply helper functions that make it easier to find this information). Both functions need to be called with the return value of <code>getiterator</code> as the argument. <code>IterableTables.column_types</code> returns a vector of <code>Type</code>s that are the element types of the columns of the iterable table. <code>IterableTables.column_names</code> returns a vector of <code>Symbol</code>s with the names of the columns.</p><p>Custom conversion functions can at this point optionally check whether the iterable table implements the <code>length</code> function by checking whether <code>Base.iteratorsize(typeof(iter))==Base.HasLength()</code> (this is part of the standard iteration protocol). It is important to note that every consumer of iterable tables needs to handle the case where no length information is available, but can provide an additional, typically faster implementation if length information is provided by the source. A typical pattern might be that a consumer can pre-allocate the arrays that should hold the data from the iterable tables with the right size if length information is available from the source.</p><p>With all this information, a consumer now typically would allocate the data structures that should hold the converted data. This will almost always be very consumer specific. Once these data structures have been allocated, one can actually implement the loop that iterates over the source rows. To get good performance it is recommended that this loop is implemented in a new function (behind a function barrier), and that the function with the loop is type-stable. Often this will require the use of a generated function that generates code for each column of the source. This can avoid a loop over the columns while one is iterating over the rows. It is often key to avoid a loop over columns inside the loop over the rows, given that columns can have different types, which almost inevitably would lead to a type instability. </p><p>A good example of a custom consumer of an iterable table is the code in the <code>DataTable</code> integration.</p><h1><a class="nav-anchor" id="Creating-an-iterable-table-source-1" href="#Creating-an-iterable-table-source-1">Creating an iterable table source</a></h1><p>There are generally two strategies for turning some custom type into an iterable table. The first strategy works if one can implement a type-stable version of <code>start</code>, <code>next</code> and <code>done</code> that iterates elements of type <code>NamedTuple</code>. If that is not feasible, the strategy is to create a new iterator type. The following two sections describe both approaches.</p><h2><a class="nav-anchor" id="Directly-implementing-the-julia-base-iteration-trait-1" href="#Directly-implementing-the-julia-base-iteration-trait-1">Directly implementing the julia base iteration trait</a></h2><p>This strategy only works if the type that one wants to expose as an iterable table has enough information about the strcuture of the table that one can implement a type stable version of <code>start</code>, <code>next</code> and <code>done</code>. Typically that requires that one can deduce the names and types of the columns of the table purely from the type (and type parameters). For some types that works, but for other types (like <code>DataFrame</code>) this strategy won&#39;t work.</p><p>If the type one wants to expose as an iterable table allows this strategy, the implementation is fairly straightforward: one simple needs to implement the standard julia base iterator interface, and during iteration one should return <code>NamedTuple</code>s for each element. The fields in the <code>NamedTuple</code> correspond to the columns of the table, i.e. the names of the fields are the column names, and the types of the field are the column types. If the source supports some notion of missing values, it should return <code>NamedTuples</code> that have fields of type <code>DataValue{T}</code>, where <code>T</code> is the data type of the column.</p><p>It is important to not only implement <code>start</code>, <code>next</code> and <code>end</code> from the julia iteration protocoll. Iterable tables also always require that <code>eltype</code> is implemented. Finally, one should either implement <code>length</code>, if the source supports returning the number of rows without expensive computations, or one should add a method <code>iteratorsize</code> that returns <code>SizeUnknown()</code> for the custom type.</p><p>The implementation of a type stable <code>next</code> method typically requires the use of generated functions.</p><h2><a class="nav-anchor" id="Creating-a-custom-iteration-type-1" href="#Creating-a-custom-iteration-type-1">Creating a custom iteration type</a></h2><p>For types that don&#39;t have enough information encoded in their type to implement a type stable version of the julia iteration interface, the best strategy is to create a custom iteration type that implements the julia iteration interface and has enough information.</p><p>For example, for the <code>MyTable</code> type one might create a new iterator type called <code>MyTableIterator{T}</code> that holds the type of the <code>NamedTuple</code> that this iterator will return in <code>T</code>.</p><p>To expose this new iterator type to consumers, one needs to add a method to the <code>IterableTables.getiterator</code> function. This function takes an instance of the type one wants to expose as an iterable table, and returns a new type that should actually be used for the iteration itself. For example, <code>function IterableTables.getiterator(table::MyTable)</code> would return an instance of <code>MyTableIterator{T}</code>.</p><p>In addition to adding a method to <code>getiterator</code>, one must also add methods to the <code>IterableTables.isiterable</code> and <code>IterableTables.isiterabletable</code> functions for the type one wants to turn into an iterable table, in both cases those methods should return <code>true</code>.</p><p>The final step is to implement the full julia iteration interface for the custom iterator type that one returned from <code>getiterator</code>. All the same requirements that were discussed in the previous section apply here as well.</p><p>An example of this strategy is the <code>DataTable</code> integration.</p><footer><hr/><a class="previous" href="userguide.html"><span class="direction">Previous</span><span class="title">User Guide</span></a><a class="next" href="developerguide.html"><span class="direction">Next</span><span class="title">Developer Guide</span></a></footer></article></body></html>
